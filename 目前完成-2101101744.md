<-- 一、跳转注册或更新个人数据接口： -->

POST
"/api/register"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
user_name（用户名）、
user_dgof_salt（用户口味咸淡之类的）、
user_series（用户喜爱的菜系）
user_bedroom（用户住的宿舍楼）

返回值：
返回字符串"注册成功"或"更新完成",若用户未登录，则返回"请先登录"

<-- 二、检测用户是否是第一次登录： -->

POST
"/api/user_login"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
没有

返回值：
1）如果用户有注册：返回字符串"用户未注册"
2）如果用户没有注册：返回字符串"用户已注册"

<-- 三、获取个人爱好页面的数据： -->

GET
"/api/get_userinfo"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
没有

返回值：
一个储存有个人信息的键值对：userinfo
可以通过：userinfo[0].datavalues.属性 来读取
属性有：
user_name （存放用户昵称）
user_dgof_salt （用户口味咸淡）
user_series（用户喜爱的菜系）
user_bedroom （用户居住的宿舍）

<-- 四、获取个人收藏菜品的数据： -->

GET
"/api/myfavorite"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
没有

返回值：
一个储存有收藏菜品信息的键值对：favorite_food_alldata
可以通过：favorite_food_alldata[0][i].food_name 来读取食物名称
favorite_food_alldata[0][i].food_id 来读取食物 id
favorite_food_alldata[0][i].food_degree 来读取食物评分
favorite_food_alldata[0][i].food_price 来读取食物价格
favorite_food_alldata[1][i].store_name 来读取商铺名称
favorite_food_alldata[1][i].dining_name 来读取餐厅名称
可能有多个食物，需要构建 for 循环

<-- 五、添加个人盲盒订单的数据： -->

POST
"/api/rand_orders"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
foodid[i] （采纳的盲盒的三个食物 id）

返回值：
返回字符串 "下单完成"

<-- 六、添加推荐后个人订单的数据： -->

POST
"/api/orders"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
foodid （采纳的推荐的食物 id）

返回值：
返回字符串 "下单完成"

<-- 七、查询个人历史五次订单： -->

GET
"/api/orderhistory"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
没有

返回值：
一个记录用户数据的数组键值对：order_fivedays
使用方法： 1)假设你要查询最近一天的记录，那么就是：order_fivedays[0]
假设你要查询上上天的记录，那么就是：order_fivedays[1]

2)假设你要查询最近一天的记录中的其中一个菜品，那么就是：order_fivedays[0][0]
假设你要查询最近一天的记录中的第二个菜品，那么就是：order_fivedays[0][1]

3)假设你要查询最近一天的记录中的其中一个菜品的名称，那么就是：order_fivedays[0][0].food_name
假设你要查询最近一天的记录中的其中一个菜品的 id，那么就是：order_fivedays[0][0].food_id

<-- 八、上传用户对某食品的打分： -->

POST
"/api/setdegree"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
foodid （被打分的食物 id）
fooddegree （用户对该食物的打分，为 0-100）

返回值：
如果是首次打分，会返回一个字符串（"评分完成"）
如果不是首次打分，会返回一个字符串（"更新完成"）

<-- 九、获取用户对某食物的打分： -->

GET
"/api/getuserdegree"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
foodid （要查询平均分的食物 id）

返回值：

1. 如果用户从来没打过分，会返回一个字符串："没有记录"
2. 如果用户有打分记录，会返回一个包含分数的键值对：userdegree
   通过 userdegree.user_degree 可以读取打分

<-- 十、更新某个食物的平均评分： -->

GET
"/api/setfooddegree"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
foodid （要查询平均分的食物 id）

返回值：
一个包含平均分的键值对：degree
通过 degree.avg_degree 可以读取平均分

<-- 十一、获取某店铺对应的信息： -->

GET
"/api/get_store_dining"
需要请求的 headers：
x-wx-openid（微信的 openid）

需要请求的 query（就是从网页向后端传的数据）：
storeid （要查询店铺的 id）

返回值：
一个包含店铺信息的键值对

<-- 十二、一个用于获取盲盒与推荐菜单的接口-->

GET
"/api/get_blindbox"
需要请求的 headers：
x-wx-openid（微信的 openid）

返回值：
一个包含二十道推荐菜品的键值对

<-- 十三、一个用于获取菜品评分的接口 -->

GET
"/api/get_food_degree"

需要请求的 headers：
没有

需要请求的 query（就是从网页向后端传的数据）：
foodid （要查询食物的 id）

返回值：
一个包含菜品评分的键值对,使用方式为获取 res.food_degree

<-- 十四、用于请求食物价格的接口 -->

GET
"/api/getfoodprice"

需要请求的 headers：
没有

需要请求的 query（就是从网页向后端传的数据）：
foodid （要查询食物的 id）

返回值：
一个包含菜品价格的键值对,使用方式为获取 res.food_price

<-- 下面是用于写入数据库的一些接口，小程序无需调用 -->

<-- 一、用于注册餐厅的接口 -->

POST
"/dining_id"
需要请求的 headers：
没有

需要请求的 query（就是从网页向后端传的数据）：
diningname （餐厅名称）
diningaddress （餐厅地址）

<-- 二、用于注册商铺的接口 -->

POST
"/store_id"
需要请求的 headers：
没有

需要请求的 query（就是从网页向后端传的数据）：
storename （商铺名称）
diningid （餐厅 id）

-------装 ejs 和 cookie-parser
-------目前写到能够提供所有食物的组合
